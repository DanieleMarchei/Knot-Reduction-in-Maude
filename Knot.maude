fmod GAUSS-CODE is

   protecting INT .
   sorts NeGauss Gauss .

   subsorts Int < NeGauss < Gauss .

   op ~ : -> Gauss [ctor] .

   --- Concatenation operator for every possibility
   op _;_ : Int     Int     -> NeGauss [assoc id: ~ ctor] .
   op _;_ : Int     Gauss   -> NeGauss [ditto] .
   op _;_ : Gauss   Int     -> NeGauss [ditto] .
   op _;_ : Gauss   Gauss   -> Gauss   [ditto] .
   op _;_ : Int     NeGauss -> NeGauss [ditto] .
   op _;_ : NeGauss Int     -> NeGauss [ditto] .
   op _;_ : NeGauss NeGauss -> NeGauss [ditto] .
   op _;_ : NeGauss Gauss   -> NeGauss [ditto] .
   op _;_ : Gauss   NeGauss -> NeGauss [ditto] .

   op maxCross     : Gauss -> Int     . *** Returns the max positive cross number present
   op nextPositive : Gauss -> Int     . *** Returns the next max cross number
   op nextNegative : Gauss -> Int     . *** Returns the next min cross number
   op next         : Gauss -> NeGauss . *** Returns a new NeGauss (I ; - I) such that I = maxCross + 1

   var G   : Gauss   .
   var NeG : NeGauss .
   var I   : Int     .

   --- MAXCROSS OPERATION
   eq maxCross(I)       = I .
   eq maxCross(NeG ; I) = if I > maxCross(NeG) then I else maxCross(NeG) fi .

   --- NEXT OPERATION
   eq next(NeG)         =  ((maxCross(NeG) + 1) ; - (maxCross(NeG) + 1)) .
   eq nextPositive(NeG) =    maxCross(NeG) + 1  .
   eq nextNegative(NeG) = - (maxCross(NeG) + 1) .

endfm

mod R-MOVES is
   
   protecting GAUSS-CODE .

   vars G     : Gauss   .
   var  NeG   : NeGauss .
   vars I K J : Int     .

   --- application of move 2 (remove double over/under crossings)
   rl [move2] :   I ;   K ; G ; - K ; - I => G .
   rl [move2] : - I ; - K ; G ;   K ;   I => G .
   rl [move2] :   I ;   K ; G ; - I ; - K => G .
   rl [move2] : - I ; - K ; G ;   I ;   K => G .

   --- application of move 1 (remove loop)
   rl [move1] : - I ;   I => ~ .
   rl [move1] :   I ; - I => ~ .

   --- application of move 3 (translation of a strand over a cross)
   rl [move3] :   I ;   K ; NeG ; - K ;   J =>   K ;   J ; NeG ;   I ; - K .
   rl [move3] : - I ;   K ; NeG ; - K ; - J =>   K ; - J ; NeG ; - I ; - K .
   rl [move3] :   I ; - K ; NeG ;   K ;   J => - K ;   J ; NeG ;   I ;   K .
   rl [move3] : - I ; - K ; NeG ;   K ; - J => - K ; - J ; NeG ; - I ;   K .
   rl [move3] : - I ;   K ; NeG ; - K ;   J =>   K ;   J ; NeG ; - I ; - K .
   rl [move3] : - I ; - K ; NeG ;   K ;   J => - K ;   J ; NeG ; - I ;   K .
   rl [move3] :   I ;   K ; NeG ; - K ; - J =>   K ; - J ; NeG ;   I ; - K .
   rl [move3] :   I ; - K ; NeG ;   K ; - J => - K ; - J ; NeG ;   I ;   K .

   --- application of inverse move 3
   rl [move3Inv] :   K ;   J ; NeG ;   I ; - K =>   I ;   K ; NeG ; - K ;   J .
   rl [move3Inv] :   K ; - J ; NeG ; - I ; - K => - I ;   K ; NeG ; - K ; - J .
   rl [move3Inv] : - K ;   J ; NeG ;   I ;   K =>   I ; - K ; NeG ;   K ;   J .
   rl [move3Inv] : - K ; - J ; NeG ; - I ;   K => - I ; - K ; NeG ;   K ; - J .
   rl [move3Inv] :   K ;   J ; NeG ; - I ; - K => - I ;   K ; NeG ; - K ;   J .
   rl [move3Inv] : - K ;   J ; NeG ; - I ;   K => - I ; - K ; NeG ;   K ;   J .
   rl [move3Inv] :   K ; - J ; NeG ;   I ; - K =>   I ;   K ; NeG ; - K ; - J .
   rl [move3Inv] : - K ; - J ; NeG ;   I ;   K =>   I ; - K ; NeG ;   K ; - J .

   --- application of inverse of move 1
   rl [move1Inv] : G ; NeG => G ; next(G ; NeG) ; NeG .

   --- application of inverse of move 2 
   rl [move2Inv] : G ; NeG => G ; nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ;       nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG) ; NeG     .
   rl [move2Inv] : G ; NeG =>     nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ; G ;   nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG) ; NeG     .
   rl [move2Inv] : G ; NeG =>     nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ;       nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG) ; G ; NeG .
   rl [move2Inv] : G ; NeG => G ; nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ; NeG ; nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG)           . 

endm