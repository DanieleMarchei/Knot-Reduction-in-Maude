fmod GAUSS-CODE is

   protecting INT .
   sorts NeGauss Gauss .

   subsorts Int < NeGauss < Gauss .

   op ~ : -> Gauss [ctor] .

   op _;_ : Int     Int     -> NeGauss [assoc id: ~ ctor] .
   op _;_ : Int     Gauss   -> NeGauss [ditto] .
   op _;_ : Gauss   Int     -> NeGauss [ditto] .
   op _;_ : Gauss   Gauss   -> Gauss   [ditto] .
   op _;_ : Int     NeGauss -> NeGauss [ditto] .
   op _;_ : NeGauss Int     -> NeGauss [ditto] .
   op _;_ : NeGauss NeGauss -> NeGauss [ditto] .
   op _;_ : NeGauss Gauss   -> NeGauss [ditto] .
   op _;_ : Gauss   NeGauss -> NeGauss [ditto] .

   op next         : Gauss -> Gauss .
   op nextPositive : Gauss -> Gauss .
   op nextNegative : Gauss -> Gauss .
   op maxCross     : Gauss -> Int   .

   var G   : Gauss .
   var NeG : NeGauss .
   var I   : Int .

   --- MAXCROSS OPERATION
   eq maxCross(I)       = I .
   eq maxCross(NeG ; I) = if I > maxCross(NeG) then I else maxCross(NeG) fi .

   --- NEXT OPERATION
   eq next(NeG)         =  ((maxCross(NeG) + 1) ; - (maxCross(NeG) + 1)) .
   eq nextPositive(NeG) =    maxCross(NeG) + 1  .
   eq nextNegative(NeG) = - (maxCross(NeG) + 1) .

endfm

mod R-MOVES is
   
   protecting GAUSS-CODE .

   vars G : Gauss .
   var NeG : NeGauss .
   vars I K J : Int .

   --- application of move 1 (remove loop)
   rl [move1] : - I ;   I => ~ .
   rl [move1] :   I ; - I => ~ .

   --- application of move 2
   rl [move2] :   I ;   K ; G ; - K ; - I => G .
   rl [move2] : - I ; - K ; G ;   K ;   I => G .
   rl [move2] :   I ;   K ; G ; - I ; - K => G .
   rl [move2] : - I ; - K ; G ;   I ;   K => G .

   --- application of move 3
   rl [move3] :   I ;   K ; NeG ; - K ;   J =>   K ;   J ; NeG ;   I ; - K .
   rl [move3] : - I ;   K ; NeG ; - K ; - J =>   K ; - J ; NeG ; - I ; - K .
   rl [move3] :   I ; - K ; NeG ;   K ;   J => - K ;   J ; NeG ;   I ;   K .
   rl [move3] : - I ; - K ; NeG ;   K ; - J => - K ; - J ; NeG ; - I ;   K .
   
   rl [move3] : - I ;   K ; NeG ; - K ;   J =>   K ;   J ; NeG ; - I ; - K .
   rl [move3] : - I ; - K ; NeG ;   K ;   J => - K ;   J ; NeG ; - I ;   K .
   rl [move3] :   I ;   K ; NeG ; - K ; - J =>   K ; - J ; NeG ;   I ; - K .
   rl [move3] :   I ; - K ; NeG ;   K ; - J => - K ; - J ; NeG ;   I ;   K .

   --- application of inverse move 3
   rl [move3Inv] :   K ;   J ; NeG ;   I ; - K =>   I ;   K ; NeG ; - K ;   J .
   rl [move3Inv] :   K ; - J ; NeG ; - I ; - K => - I ;   K ; NeG ; - K ; - J .
   rl [move3Inv] : - K ;   J ; NeG ;   I ;   K =>   I ; - K ; NeG ;   K ;   J .
   rl [move3Inv] : - K ; - J ; NeG ; - I ;   K => - I ; - K ; NeG ;   K ; - J .
   rl [move3Inv] :   K ;   J ; NeG ; - I ; - K => - I ;   K ; NeG ; - K ;   J .
   rl [move3Inv] : - K ;   J ; NeG ; - I ;   K => - I ; - K ; NeG ;   K ;   J .
   rl [move3Inv] :   K ; - J ; NeG ;   I ; - K =>   I ;   K ; NeG ; - K ; - J .
   rl [move3Inv] : - K ; - J ; NeG ;   I ;   K =>   I ; - K ; NeG ;   K ; - J .

   --- application of inverse of move 1 (add loop)
   rl [move1Inv] : G ; NeG => G ; next(G ; NeG) ; NeG .

   --- application of inverse of move 2 
   rl [move2Inv] : G ; NeG => G ; nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ; nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG) ; NeG .
   rl [move2Inv] : G ; NeG => nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ; G ; nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG) ; NeG .
   rl [move2Inv] : G ; NeG => nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ; nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG) ; G ; NeG .
   rl [move2Inv] : G ; NeG => G ; nextPositive(G ; NeG) ; nextPositive(next(G ; NeG)) ; NeG ; nextNegative(next(G ; NeG)) ; nextNegative(G ; NeG) .

endm